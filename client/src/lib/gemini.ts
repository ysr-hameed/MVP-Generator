// This file provides client-side utilities for interacting with the Gemini service
// The actual AI processing is handled by the server-side service

export interface MvpPlan {
  coreFeatures: string[];
  techStack: {
    frontend: string;
    backend: string;
    database: string;
    payment?: string;
    hosting?: string;
  };
  monetizationStrategy: string;
  timeline: {
    mvp: string;
    launch: string;
    growth: string;
  };
  estimatedCost: {
    development: string;
    monthly: string;
  };
  marketAnalysis: {
    targetMarket: string;
    competition: string;
    opportunity: string;
  };
  nextSteps: string[];
}

export interface MvpGenerationRequest {
  idea: string;
  industry: string;
  targetAudience: string;
  budget: string;
}

export class GeminiClient {
  private baseUrl: string;

  constructor(baseUrl = '') {
    this.baseUrl = baseUrl;
  }

  async generateMvpPlan(request: MvpGenerationRequest): Promise<MvpPlan> {
    const response = await fetch(`${this.baseUrl}/api/mvp/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to generate MVP plan');
    }

    const result = await response.json();
    return result.data;
  }

  // Utility methods for client-side processing
  static validateMvpPlan(plan: any): plan is MvpPlan {
    return (
      plan &&
      Array.isArray(plan.coreFeatures) &&
      typeof plan.techStack === 'object' &&
      typeof plan.monetizationStrategy === 'string' &&
      typeof plan.timeline === 'object' &&
      typeof plan.estimatedCost === 'object' &&
      typeof plan.marketAnalysis === 'object' &&
      Array.isArray(plan.nextSteps)
    );
  }

  static estimateReadingTime(plan: MvpPlan): number {
    const words = [
      ...plan.coreFeatures,
      plan.monetizationStrategy,
      plan.techStack.frontend,
      plan.techStack.backend,
      plan.techStack.database,
      plan.marketAnalysis.targetMarket,
      plan.marketAnalysis.competition,
      plan.marketAnalysis.opportunity,
      ...plan.nextSteps,
    ].join(' ').split(' ').length;

    return Math.max(1, Math.ceil(words / 200)); // 200 WPM average reading speed
  }

  static formatForExport(plan: MvpPlan, format: 'text' | 'markdown' = 'text'): string {
    if (format === 'markdown') {
      return `
# MVP Plan Generated by AI

## Core Features
${plan.coreFeatures.map(feature => `- ${feature}`).join('\n')}

## Tech Stack
- **Frontend:** ${plan.techStack.frontend}
- **Backend:** ${plan.techStack.backend}
- **Database:** ${plan.techStack.database}
${plan.techStack.payment ? `- **Payment:** ${plan.techStack.payment}` : ''}
${plan.techStack.hosting ? `- **Hosting:** ${plan.techStack.hosting}` : ''}

## Monetization Strategy
${plan.monetizationStrategy}

## Timeline
- **MVP Development:** ${plan.timeline.mvp}
- **Market Launch:** ${plan.timeline.launch}
- **Growth Phase:** ${plan.timeline.growth}

## Estimated Costs
- **Development:** ${plan.estimatedCost.development}
- **Monthly Operations:** ${plan.estimatedCost.monthly}

## Market Analysis
**Target Market:** ${plan.marketAnalysis.targetMarket}

**Competition:** ${plan.marketAnalysis.competition}

**Opportunity:** ${plan.marketAnalysis.opportunity}

## Next Steps
${plan.nextSteps.map(step => `1. ${step}`).join('\n')}

---
*Generated by MVP Generator AI - ${new Date().toLocaleDateString()}*
      `;
    }

    return `
MVP PLAN GENERATED BY AI

CORE FEATURES:
${plan.coreFeatures.map(feature => `• ${feature}`).join('\n')}

TECH STACK:
• Frontend: ${plan.techStack.frontend}
• Backend: ${plan.techStack.backend}
• Database: ${plan.techStack.database}
${plan.techStack.payment ? `• Payment: ${plan.techStack.payment}` : ''}
${plan.techStack.hosting ? `• Hosting: ${plan.techStack.hosting}` : ''}

MONETIZATION STRATEGY:
${plan.monetizationStrategy}

TIMELINE:
• MVP Development: ${plan.timeline.mvp}
• Market Launch: ${plan.timeline.launch}
• Growth Phase: ${plan.timeline.growth}

ESTIMATED COSTS:
• Development: ${plan.estimatedCost.development}
• Monthly Operations: ${plan.estimatedCost.monthly}

MARKET ANALYSIS:
Target Market: ${plan.marketAnalysis.targetMarket}
Competition: ${plan.marketAnalysis.competition}
Opportunity: ${plan.marketAnalysis.opportunity}

NEXT STEPS:
${plan.nextSteps.map(step => `• ${step}`).join('\n')}

Generated by MVP Generator AI - ${new Date().toLocaleDateString()}
    `;
  }

  static calculateComplexityScore(plan: MvpPlan): {
    score: number;
    level: 'Simple' | 'Moderate' | 'Complex' | 'Advanced';
    factors: string[];
  } {
    let score = 0;
    const factors: string[] = [];

    // Feature complexity
    if (plan.coreFeatures.length > 8) {
      score += 2;
      factors.push('High feature count');
    } else if (plan.coreFeatures.length > 5) {
      score += 1;
      factors.push('Moderate feature count');
    }

    // Tech stack complexity
    const complexTech = ['microservices', 'kubernetes', 'machine learning', 'blockchain', 'ai'];
    const techString = `${plan.techStack.frontend} ${plan.techStack.backend} ${plan.techStack.database}`.toLowerCase();
    
    if (complexTech.some(tech => techString.includes(tech))) {
      score += 2;
      factors.push('Advanced technology stack');
    }

    // Timeline complexity
    const mvpTime = plan.timeline.mvp.toLowerCase();
    if (mvpTime.includes('month') && parseInt(mvpTime) > 6) {
      score += 2;
      factors.push('Extended development timeline');
    } else if (mvpTime.includes('month') && parseInt(mvpTime) > 3) {
      score += 1;
      factors.push('Moderate development timeline');
    }

    // Cost complexity
    const devCost = plan.estimatedCost.development.toLowerCase();
    if (devCost.includes('k') && parseInt(devCost) > 100) {
      score += 2;
      factors.push('High development cost');
    } else if (devCost.includes('k') && parseInt(devCost) > 50) {
      score += 1;
      factors.push('Moderate development cost');
    }

    let level: 'Simple' | 'Moderate' | 'Complex' | 'Advanced';
    if (score <= 1) level = 'Simple';
    else if (score <= 3) level = 'Moderate';
    else if (score <= 5) level = 'Complex';
    else level = 'Advanced';

    return { score, level, factors };
  }
}

export const geminiClient = new GeminiClient();
